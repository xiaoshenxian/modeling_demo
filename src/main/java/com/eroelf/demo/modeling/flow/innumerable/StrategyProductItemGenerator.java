package com.eroelf.demo.modeling.flow.innumerable;

import java.util.HashMap;
import java.util.Map;

import com.eroelf.demo.modeling.feature.item.ProductItem;
import com.eroelf.demo.modeling.flow.ProductItemGroupStatistics;
import com.eroelf.javaxsx.util.ml.feature.BatchScoreableRestrictedBatchSample;
import com.eroelf.javaxsx.util.ml.flow.controller.InnumerableFlowHandler;
import com.eroelf.javaxsx.util.ml.flow.controller.filter.ItemFilterHandler;
import com.eroelf.javaxsx.util.ml.flow.estimate.InnumerableItemGenerator;
import com.eroelf.javaxsx.util.ml.flow.estimate.statistics.ItemGroupStatistics;

public class StrategyProductItemGenerator extends InnumerableItemGenerator<ProductItem>
{
	// This map is used to save strategy generated items.
	// The working flow will automatically do duplicate detection and feature combination, since different strategies may generate same items. See UpdatableByItem.
	private Map<ProductItem, ProductItem> productMap=new HashMap<>();

	private InnumerableFlowHandler<ProductItem> flowHandler;
	private ItemFilterHandler<ProductItem> filterHandler;
	private boolean isDebug;

	public StrategyProductItemGenerator(InnumerableFlowHandler<ProductItem> flowHandler, ItemFilterHandler<ProductItem> filterHandler, boolean isDebug)
	{
		this.flowHandler=flowHandler;
		this.filterHandler=filterHandler;
		this.isDebug=isDebug;
	}

	@Override
	protected ProductItem findExistedItem(ProductItem item)
	{
		// Return the item that has already been generated by another strategy but should be regarded as the same one as the input item. return null for new items.
		// Do NOT use if(productMap.containsKey(item))return item! Because they are different objects!
		return productMap.get(item);
	}

	@Override
	protected void saveToExisted(ProductItem item)
	{
		// The item is a newly generated one, save it to somewhere.
		productMap.put(item, item);
	}

	// Traverse all samples after all strategies have been executed.
	@Override
	protected Iterable<ProductItem> getCandidates()
	{
		return productMap.values();
	}

	@Override
	protected InnumerableFlowHandler<ProductItem> getFlowHandler()
	{
		// Get the flow handler.
		// One can either pass it from outside just like this example to decouple this class and the business, or construct it in this method.
		return flowHandler;
	}

	@Override
	protected ItemFilterHandler<ProductItem> getFilterHandler()
	{
		// If there needs a filter handler, return it here.
		return filterHandler!=null ? filterHandler : super.getFilterHandler();
	}

	@Override
	protected BatchScoreableRestrictedBatchSample<ProductItem> createBatchSample(int batchSize)
	{
		// A class to support batch scoring.
		return new BatchScoreableRestrictedBatchSample<ProductItem>(batchSize);
	}

	@Override
	protected void verbose(ProductItem item)
	{
		// Retain some redundant information related to the item.
		// In this example, saving the feature string if under a debug status.
		// Here, the redundant information is retained by the item object, of cause other places would be OK.
		if(isDebug)
			item.getFeatureString();
	}

	@Override
	protected ItemGroupStatistics<ProductItem> getItemGroupStatistics()
	{
		// What kind of statistics the working flow needs to calculate and use?
		// These statistics will be used by the filter returned by ItemFilterHandler::getAfterFilter, see the filter example class for detail.
		// One may like to pass the filter handler from outside of the class to gain more flexible.
		return filterHandler!=null ? new ProductItemGroupStatistics() : super.getItemGroupStatistics();
	}
}
